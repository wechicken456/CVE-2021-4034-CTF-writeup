# CVE-2021-4034-CTF-writeup
This is a CTF pwn challenge written in C which requires the user to exploit the CVE-2021-4034 vulnerability. Players are given 2 binaries in the [challenge](challenge) directory in this repo. The `chal` binary implements the CTF challenge and the `shelly.so` is a helper binary.

## Blind Analysis
Running the `chal` binary gives us a vague idea of what this binary does: 
```
WELCOME TO THE HUB CTRL+ALT+DELICIOUS
We're not just a sandwich hub. We are the beacon of flavors, serving a symphony in every byte

1. ENTER THE HUB
2. QUIT
1
Order number: 0x7ffde93681f0
Enter your name: tin
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
1
Pick your bread: aaaa
Select your spread: bbbb
Choose your veg: cccc
Slam your meat & egg: dddc
Any side notes for the cook? 0000
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
1
Pick your bread: AAAA
Select your spread: BBBB
Choose your veg: CCCC
Slam your meat & egg: DDDD
Any side notes for the cook? 1111
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
3
Enter order index: 0
aaaa, bbbb, cccc, dddc, 0000
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
3
Enter order index: 1
AAAA, BBBB, CCCC, DDDD, 1111
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
4
Enter order index: 1
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
3
Enter order index: 1
Invalid index!
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
5
/notes ./tin/notes
1. ADD NEW ORDER
2. EDIT ORDER
3. SHOW ORDER
4. CANCEL ORDER
5. CHECKOUT
6. DONE
6
1. ENTER THE HUB
2. QUIT
2
Come again :)
```
Playing around with the input size in the `Add` function and the indices of the `Cancel` functions don't give us anything special (no overflow or segmentation fault). Though, some interseting things:
  - It looks like the orders are place in a list (linked list perhaps) and they are 0-indexed?
  - There is this `Order number: 0x7ffde93681f0` which seems to print some location on the stack?
  - Also, the program creates a directory with our input name along with 3 executables, one of which is the helper binary file we are given:
```
peasant@Tin-VM:~/Desktop$ ls
chal  chal.c  shelly.so  solve.py  tin
peasant@Tin-VM:~/Desktop$ ls -l tin/
total 28
-rwxrwx--- 1 peasant vboxsf     5 Feb  4 14:33 notes
-rwxrwx--- 1 peasant vboxsf    20 Feb  4 14:33 recipe
-rwxr-x--- 1 peasant vboxsf 16488 Feb  4 14:33 shelly.so
peasant@Tin-VM:~/Desktop$ ls
chal  chal.c  shelly.so  solve.py  tin
peasant@Tin-VM:~/Desktop$ cat tin/notes 
0000
peasant@Tin-VM:~/Desktop$ cat tin/recipe 
aaaa
bbbb
cccc
dddc

```

**The executables contain our input.**

---

## Ghidra analysis

You can play around with the other functions and hope that you might run into some bugs (which is probable), but I'm gonna cut to the chase and open the program in Ghidra.

Comparing the strings that appear while running the program and the strings that are present in Ghidra, we can rename some of the `FUN_*` functions into familiar names:
```C
undefined8 main(void)

{
  int iVar1;
  size_t sVar2;
  undefined2 *puVar3;
  long in_FS_OFFSET;
  int opt;
  int local_1c;
  char *local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_18 = "/recipe";
  print("WELCOME TO THE HUB CTRL+ALT+DELICIOUS\n");
  print(
       "We\'re not just a sandwich hub. We are the beacon of flavors, serving a symphony in every by te\n\n"
       );
  while( true ) {
    print("1. ENTER THE HUB\n");
    print("2. QUIT\n");
    __isoc99_scanf(&DAT_001030c5,&opt);
    getc(stdin);
    if (opt != 1) break;
    printf("Order number: %p\n",&local_18);
    print("Enter your name: ");
    __isoc99_scanf(&DAT_0010334f,&DAT_00105120);
    sVar2 = strlen(&DAT_00105120);
    puVar3 = (undefined2 *)malloc(sVar2 + 2);
    DAT_00105100 = puVar3;
    *puVar3 = 0x2f2e;
    *(undefined *)(puVar3 + 1) = 0;
    strcpy((char *)(DAT_00105100 + 1),&DAT_00105120);
    iVar1 = FUN_001022f0(DAT_00105100,&DAT_00105060);
    if (iVar1 == -1) {
      mkdir((char *)DAT_00105100,0x1c0);
    }
    DAT_00105140 = 0;
    order_cnt = 0;
    for (local_1c = 0; local_1c < 10; local_1c = local_1c + 1) {
      *(undefined8 *)(&ptr_array + (long)local_1c * 8) = 0;
    }
    main_menu();
  }
  print("Come again :)\n");
```

The `printf("Order number: %p\n",&local_18);` **prints out a location of a local variable on the stack.**


We see a `mkdir` call, which **creates a directory with our input name in the current directory.** 


These are consistent with our observation when we ran the program. Then it initializes some variable before calling the `main_menu` function, which looks something like: 
```C
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              print("1. ADD NEW ORDER\n");
              print("2. EDIT ORDER\n");
              print("3. SHOW ORDER\n");
              print("4. CANCEL ORDER\n");
              print("5. CHECKOUT\n");
              print("6. DONE\n");
              __isoc99_scanf(&DAT_001030c5,&local_40);
              getc(stdin);
              if (local_40 != 1) break;
              add_order();
            }
            if (local_40 != 2) break;
            edit_order();
          }
          if (local_40 != 3) break;
          show_order();
        }
        if (local_40 != 4) break;
        cancel_order();
      }
      if (local_40 != 5) break;
      checkout();
    }
    if (local_40 == 6) break;
    if (local_40 == 0x539) {
      print(
           "\nGORDON RAMSAY: Finally, a worthy opponent, our battle will be legendary! I BET YOU CAN \'T GUESS THE SECRET RECIPE.\n"
           );
      fgets(inp,0x20,stdin);
      getrandom(random-bytes,0x10,0);
      for (local_3c = 0; local_3c < 0x10; local_3c = local_3c + 1) {
        if (inp[local_3c] != random-bytes[local_3c]) {
          print("...*Nuh Uh!*...\n");
                    /* WARNING: Subroutine does not return */
          exit(0);
        }
        print("...*Ooh Yes.. sCruMpTioUs*...");
      }
      print("Fine... I\'ll give you a taste.\n");
      FUN_00101504();
    }
```
If you're not familiar with REV, this is the decompilation for the `switch` statement in C. There's one interesting option a.k.a `0x539`.  It allows the players to guess `0x10` random bytes. If all the bytes are equal, then it calls `FUN_00101504();` which calls `system("cat flag.txt");`. Otherwise, the program exits. 

However, bruteforcing 16 random bytes is equivalent to trying all 256**16 = 340282366920938463463374607431768211456 possibilities. Good luck with this one lol. 

Even if you pass all the possibilities, the program is still unprivileged, so it can't read the flag. This `cat flag.txt` statement is intentional, not only to throw trick unexperienced players into picking this `0x539` menu option, but also to prevent the players to just simply call this function to read the flag, which we will dive into later.
***
### Add
```C
  int iVar1;
  undefined8 *puVar2;
  void *pvVar3;
  undefined8 *ptr2;
  
  if (order_cnt < 10) {
    puVar2 = (undefined8 *)malloc(0x30);
    print("Pick your bread: ");
    readline(puVar2 + 1,8);
    print("Select your spread: ");
    readline(puVar2 + 2,8);
    print("Choose your veg: ");
    readline(puVar2 + 3,8);
    print("Slam your meat & egg: ");
    readline(puVar2 + 4,9);
    iVar1 = order_cnt;
    pvVar3 = malloc(0x30);
    *(void **)(&ptr_array + (long)iVar1 * 8) = pvVar3;
    *puVar2 = *(undefined8 *)(&ptr_array + (long)order_cnt * 8);
    print("Any side notes for the cook? ");
    readline(*puVar2,0x30);
    puVar2[5] = 0;
    if (DAT_00105140 != (undefined8 *)0x0) {
      for (ptr2 = DAT_00105140; ptr2[5] != 0; ptr2 = (undefined8 *)ptr2[5]) {
      }
      ptr2[5] = puVar2;
      puVar2 = DAT_00105140;
    }
    DAT_00105140 = puVar2;
    order_cnt = order_cnt + 1;
  }
...
```
If some of the variables don't look easily readable like this for you, it's because I took some time to rename them into these, which you should do while reverse engineering to keep track of things. Alright, let's get to the main points:
- `puVar2` is a malloc chunk that is `0x30` large.
- 0-th field is `puVar3` pointer, which is 8-byte long.
- The next 4 fields are each 8-byte long, though we can read 9 bytes into the 4-th field, so we can overflow 1 byte into the 5-th field.
- However, the line `puVar2[5] = 0;` overwrites our 1-byte overflow to NULL anyway.
- Then if the global variable `DAT_00105140 == 0`, then we just set it to the new chunk, so this might be a `head` pointer for the list?
- Otherwise, we loop until the last chunk in the current list, and set its 5-th field to the new chunk. => **5-th field is the pointer to the next chunk in the linked list.**

---
### Edit
```C
...
  print("Enter order index: ");
  __isoc99_scanf(&DAT_001030c5,&local_20);
  getc(stdin);
  if ((local_20 < 0) || (order_cnt <= local_20)) {
    print("Invalid index!\n");
  }
  else {
    local_18 = head;
    for (local_1c = 0; local_1c != local_20; local_1c = local_1c + 1) {
      local_18 = (undefined8 *)local_18[5];
    }
    print("Pick your bread: ");
    readline(local_18 + 1,8);
    print("Select your spread: ");
    readline(local_18 + 2,8);
    print("Choose your veg: ");
    readline(local_18 + 3,8);WE
    print("Slam your meat & egg: ");
    readline(local_18 + 4,9);
    print("Any side notes for the cook? ");
    readline(*local_18,0x30);
  }
...

```
There's a check for our input index, so we can't edit arbitrary locations. 

**However, the 9-byte read in the 4-th field which overflows 1-byte into the 5-th field is still there!!! We can overwrite 1 byte into the `nxt` pointer**
***
### Show
```C
...
    if (local_18 != (undefined8 *)0x0) {
      printf("%s, %s, %s, %s, %s\n",local_18 + 1,local_18 + 2,local_18 + 3,local_18 + 4,*local_18);
    }
...
```
`%s` will print until the NULL character, so if our 4-th field is 8-byte long, then the 4th `%s` will print the 4-th field of our chunk + the `nxt` pointer value in the `5-th` field.
=> **We get a *heap* leak!!!**
***
### Cancel
Nothing interseting here. 
***
### Checkout 
```C
  strcpy(local_d8,dir_name);
  sVar2 = strlen(dir_name);
  strcpy(local_d8 + sVar2,"/recipe");
  creat(local_d8,0x1c0);
  iVar1 = open(local_d8,2);
  if (iVar1 == -1) {
    print("Error opening file f.\n");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  chmod(local_d8,0x1f8);
  strcpy(local_98,dir_name);
  sVar2 = strlen(dir_name);
  strcpy(local_98 + sVar2,"/notes");
  printf("%s %s\n","/notes",local_98);
  creat(local_98,0x1c0);
  __fd = open(local_98,2);
  if (__fd == -1) {
    print("Error opening file f_notes.\n");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  chmod(local_98,0x1f8);
```
So it creates the files `recipe` and `notes` in the directory with our input name. The `chmod` statements sets these files to executable mode: `0x1f8` and `0x1c0` are `0700` and `0770` in octal base respectively.
```
...
  for (local_ec = 0; (local_e0 != (char **)0x0 && (local_ec < order_cnt)); local_ec = local_ec + 1)
  {
    sVar2 = strlen((char *)(local_e0 + 1));
    write(iVar1,local_e0 + 1,sVar2);
    write(iVar1,&DAT_00103127,1);
    sVar2 = strlen((char *)(local_e0 + 2));
    write(iVar1,local_e0 + 2,sVar2);
    write(iVar1,&DAT_00103127,1);
    sVar2 = strlen((char *)(local_e0 + 3));
    write(iVar1,local_e0 + 3,sVar2);
    write(iVar1,&DAT_00103127,1);
    sVar2 = strlen((char *)(local_e0 + 1));
    write(iVar1,local_e0 + 4,sVar2);
    write(iVar1,&DAT_00103127,1);
    sVar2 = strlen(*local_e0);
    write(__fd,*local_e0,sVar2);
    write(__fd,&DAT_00103127,1);
    local_e0 = (char **)local_e0[5];
  }
  iVar1 = close(iVar1);
  if (-1 < iVar1) {
    iVar1 = close(__fd);
    if (-1 < iVar1) {
      local_58 = 0x2f706d742f207063;
      local_50 = 0x732e796c6c656873;
      local_48 = 0x206f;
      local_40 = 0;
      local_38 = 0;
      local_30 = 0;
      local_28 = 0;
      local_20 = 0;
      strcpy((char *)((long)&local_48 + 2),dir_name);
      system((char *)&local_58);
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return;
    }
  }
...
```
This huge messy block of code basically writes the content in our chunks to these files, then executes the commnad `cp /tmp/shelly.so dir_name`, where `dir_name` is the name we give the program at the beginning. 





